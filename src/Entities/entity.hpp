#ifndef ENTITY_HPP
#define ENTITY_HPP

#include <cmath>
#include <cassert>

namespace sim {

enum EntityType
{
  pionP   = 0,
  pionM   = 1,
  kaonP   = 2,
  kaonM   = 3,
  protonP = 4,
  protonM = 5,
  kaonS   = 6
};

class Entity {
  double px_{ 0 };
  double py_{ 0 };
  double pz_{ 0 };

 protected:
  // Set to true only on particles generated by a decay.
  bool isDecayProduct_{ false };

 public:
  // Constructor (initialize individual particle information) //////////////////////////////////////////////////////////
  Entity();
  explicit Entity(bool isDecayProduct);
  Entity(double px, double py, double pz);

  // Particle type information (static) ////////////////////////////////////////////////////////////////////////////////
  // Derived classes must make these values static constexpr.
  virtual EntityType type()   const = 0;
  virtual double     mass()   const = 0;
  virtual int        charge() const = 0;
  virtual double     width()  const;

  // Check if this entity is of "type"
  bool is(EntityType type) const;

  // Print entity attributes
  void printAttributes() const;

  // individual particle information ///////////////////////////////////////////////////////////////////////////////////
  // Check if this entity is decay product.
  inline bool isDecayProduct() const {
    // This "isDecayProduct" attribute can probably be
    return isDecayProduct_;
  }

  // Get individual momentum components
  inline double px() const {
    return px_;
  };
  inline double py() const {
    return py_;
  }
  inline double pz() const {
    return pz_;
  }

  // Get momentum (squared/norm)
  inline double p2() const {
    return (px() * px()) + (py() * py()) + (pz() * pz());
  }
  inline double p() const {
    return std::sqrt(p2());
  }

  // Get polar momentum coordinates
  // Polar angle
  inline double theta() const {
    return std::acos(pz() / p());
  }
  // Azimuth angle
  inline double phi() const {
    const double angle = std::atan(py() / px());
    const double x = px();
    const double y = py();

    // This certainly works. I Maybe it can be rewritten in a better way(?)
    return (x > 0 && y > 0) ? angle
         : (x < 0 && y > 0) ? M_PI + angle
         : (x < 0 && y < 0) ? M_PI + angle
         : (x > 0 && y < 0) ? M_PI * 2 + angle
         : 0;
  }

  // Set individual momentum components
  inline double px(double px) {
    return px_ = px;
  };
  inline double py(double py) {
    return py_ = py;
  }
  inline double pz(double pz) {
    return pz_ = pz;
  }

  // Set all momentum components
  inline void p(double px, double py, double pz) {
    this->px(px);
    this->py(py);
    this->pz(pz);
  }
  inline void pPolar(double p, double phi, double theta) {
    px(p * std::sin(theta) * std::cos(phi));
    py(p * std::sin(theta) * std::sin(phi));
    pz(p * std::cos(theta));
  }

  // Get total energy of the particle
  double energy() const;

  double traverseP() const;

  // Boost particle using lorentz vector transform.
  void boost(double betaX, double betaY, double betaZ);

  // Get invariant mass of two particles
  static double invariantMass(Entity& entity1, Entity& entity2);

  inline virtual int decayTwoEntities(Entity& entity1, Entity& entity2) {
    // Same considerations as width()
    assert(false);
    return -1;
  }

  // Destructor ////////////////////////////////////////////////////////////////////////////////////////////////////////
  // We need a virtual destructor since we will be explicitly deleting derived pointers
  inline virtual ~Entity() = default;

  // And we need to obey to the 3/5/0 rule. These are deleted, since I am not using them.
  Entity(const Entity& copyFrom)            = delete;
  Entity(Entity&&)                          = delete;
  Entity& operator=(Entity&&)               = delete;
  Entity& operator=(const Entity& copyFrom) = delete;
};

}  // namespace sim

#endif  // define ENTITY_HPP
